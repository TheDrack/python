name: Jarvis Autonomous State Machine (DEPRECATED - Use Metabolism Flow)

# ============================================================================
# WORKFLOW DEPRECATED - USE jarvis_metabolism_flow.yml
# ============================================================================
#
# Este workflow foi substitu√≠do pelo Fluxo de Metabolismo do Jarvis.
# 
# MOTIVO: Evolu√ß√£o para modelo metab√≥lico que trata o reposit√≥rio como DNA
#
# O novo sistema (jarvis_metabolism_flow.yml) implementa:
# - Conceito de DNA (reposit√≥rio) e muta√ß√µes controladas
# - Mec√¢nico Revisionador (an√°lise metab√≥lica)
# - Mec√¢nico Consertador (mutag√™nese controlada)
# - Vistoria (homeostase/sistema imunol√≥gico)
# - Controle de Loop (3 ciclos m√°ximos)
# - Comandante (consci√™ncia superior humana)
# 
# Este arquivo foi mantido temporariamente para compatibilidade.
# Use .github/workflows/jarvis_metabolism_flow.yml para novos eventos.
# 
# Data de depreca√ß√£o: 2026-02-11
# ============================================================================

# Self-Healing State Machine Implementation (LEGACY)
# Follows the state machine logic for autonomous error fixing:
# - CHANGE_REQUESTED: Auto-fixable errors
# - NEEDS_HUMAN: Infrastructure/unidentified errors
# - SUCCESS: Fix applied successfully  
# - FAILED_LIMIT: Maximum attempts reached

on:
  pull_request:
  issues:
    types: [opened, edited]
  repository_dispatch:
    types: [jarvis_order, auto_fix]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  healing_engine:
    # Trigger on:
    # - Pull requests (for testing PRs)
    # - Issues with 'auto-code' or 'jarvis-auto-report' labels
    # - Repository dispatch events from Jarvis API ('jarvis_order' or 'auto_fix')
    if: |
      github.event_name == 'pull_request' ||
      contains(github.event.issue.labels.*.name, 'auto-code') ||
      contains(github.event.issue.labels.*.name, 'jarvis-auto-report') ||
      github.event_name == 'repository_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      final_state: ${{ steps.healing_engine.outputs.final_state }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          # Install test dependencies
          pip install pytest pytest-json-report pytest-cov
          # Install project dependencies if they exist
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt || echo "Some dependencies failed, continuing..."
          fi
          if [ -f "requirements/core.txt" ]; then
            pip install -r requirements/core.txt || echo "Some core dependencies failed, continuing..."
          fi
          if [ -f "requirements/dev.txt" ]; then
            pip install -r requirements/dev.txt || echo "Some dev dependencies failed, continuing..."
          fi

      - name: Initialize State Variables
        run: |
          # Initialize state variables to prevent undefined behavior
          echo "AUTO_FIX_PR=false" >> $GITHUB_ENV
          echo "TESTS_FAILED=false" >> $GITHUB_ENV

      - name: Handle Repository Dispatch (Jarvis API)
        id: handle_dispatch
        if: github.event_name == 'repository_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.JARVIS_TOKEN_CI || github.token }}
          GH_TOKEN: ${{ secrets.JARVIS_TOKEN_CI || github.token }}
        run: |
          # Extract payload from repository_dispatch event
          INTENT="${{ github.event.client_payload.intent }}"
          INSTRUCTION="${{ github.event.client_payload.instruction }}"
          CONTEXT="${{ github.event.client_payload.context }}"
          TRIGGERED_BY="${{ github.event.client_payload.triggered_by }}"
          
          echo "Processing Jarvis API request:"
          echo "Intent: $INTENT"
          echo "Instruction: $INSTRUCTION"
          echo "Triggered by: $TRIGGERED_BY"
          
          # Build issue body from payload
          ISSUE_TITLE="ü§ñ Jarvis Request: $INTENT"
          ISSUE_BODY="## Solicita√ß√£o do Jarvis
          
          **Tipo:** $INTENT
          **Solicitado por:** $TRIGGERED_BY
          
          ### Instru√ß√£o
          $INSTRUCTION
          
          ### Contexto
          ${CONTEXT:-Nenhum contexto adicional fornecido}
          
          ---
          *Requisi√ß√£o criada automaticamente pela API do Jarvis*"
          
          # Create issue with auto-code label to trigger self-healing
          gh issue create \
            --title "$ISSUE_TITLE" \
            --body "$ISSUE_BODY" \
            --label "auto-code" \
            --label "jarvis-api" > issue_url.txt
          
          # Extract issue number from URL
          ISSUE_URL=$(cat issue_url.txt)
          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oP '/issues/\K\d+')
          
          echo "Created issue #$ISSUE_NUMBER"
          echo "DISPATCH_ISSUE_NUMBER=$ISSUE_NUMBER" >> $GITHUB_ENV
          # Use heredoc syntax for multi-line environment variable with unique delimiter
          {
            echo "DISPATCH_ISSUE_BODY<<EOF_DISPATCH_ISSUE_BODY_DELIMITER"
            echo "$ISSUE_BODY"
            echo "EOF_DISPATCH_ISSUE_BODY_DELIMITER"
          } >> $GITHUB_ENV

      - name: Check for Auto-Fix PR
        id: check_auto_fix
        if: github.event_name == 'pull_request'
        run: |
          # Check if this is an auto-fix PR by looking for autonomous_instruction.json
          if [ -f "autonomous_instruction.json" ]; then
            echo "AUTO_FIX_PR=true" >> $GITHUB_ENV
            echo "Auto-fix PR detected - autonomous_instruction.json found"
            # Don't print full file contents to avoid exposing secrets in logs
            echo "File size: $(wc -c < autonomous_instruction.json) bytes"
          else
            echo "AUTO_FIX_PR=false" >> $GITHUB_ENV
            echo "Regular PR - no autonomous_instruction.json"
          fi

      - name: Run Pytest (The Judge)
        id: tester
        if: github.event_name == 'pull_request' && env.AUTO_FIX_PR != 'true'
        run: |
          pytest --json-report --json-report-file=report.json || echo "TESTS_FAILED=true" >> $GITHUB_ENV
        continue-on-error: true

      - name: Self-Healing Logic
        id: healing_engine
        if: env.TESTS_FAILED == 'true' || github.event_name == 'repository_dispatch' || github.event_name == 'issues' || env.AUTO_FIX_PR == 'true'
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.JARVIS_TOKEN_CI || github.token }}
          GH_TOKEN: ${{ secrets.JARVIS_TOKEN_CI || github.token }}
          COPILOT_GITHUB_TOKEN: ${{ secrets.JARVIS_TOKEN_CI || github.token }}
          ISSUE_BODY: ${{ github.event_name == 'repository_dispatch' && env.DISPATCH_ISSUE_BODY || (github.event_name == 'issues' && github.event.issue.body || '') }}
          ISSUE_NUMBER: ${{ github.event_name == 'repository_dispatch' && env.DISPATCH_ISSUE_NUMBER || github.event.issue.number || '' }}
        run: |
          # Install GitHub CLI Copilot extension
          gh --version
          gh extension install github/gh-copilot || echo "Copilot extension already installed"
          
          # Authenticate gh CLI with the token
          # The GH_TOKEN env var is already set, but we need to ensure gh CLI uses it
          if ! gh auth status &>/dev/null; then
            echo "$GH_TOKEN" | gh auth login --with-token
          fi
          
          # Display auth status with details for validation
          echo "üîç Validating GitHub CLI authentication and token permissions:"
          gh auth status
          
          # Test Copilot connection to verify token has Copilot permissions
          echo "üß™ Testing Copilot connection:"
          if gh copilot explain -p "test connection" &>/dev/null; then
            echo "‚úÖ Copilot connection successful - token has Copilot permissions"
          else
            echo "‚ö†Ô∏è Copilot connection test failed - token may lack Copilot permissions"
            echo "Attempting to continue with workflow..."
          fi
          
          # Setup git authentication with the token
          gh auth setup-git
          
          # Configure Git
          git config --global user.name "Jarvis-Auto-Fixer"
          git config --global user.email "jarvis@bot.com"
          
          # Run auto-fixer based on context
          if [[ "${{ env.AUTO_FIX_PR }}" == "true" ]]; then
            echo "Running in auto-fix PR mode with autonomous_instruction.json"
            # Read the autonomous instruction file and set ISSUE_BODY env var
            if [ -f "autonomous_instruction.json" ]; then
              TITLE=$(cat autonomous_instruction.json | jq -r '.title // "Auto-fix"')
              DESCRIPTION=$(cat autonomous_instruction.json | jq -r '.description // ""')
              ERROR_LOG=$(cat autonomous_instruction.json | jq -r '.error_log // ""')
              CONTEXT=$(cat autonomous_instruction.json | jq -r '.improvement_context // ""')
              
              # Compose ISSUE_BODY from autonomous instruction (don't echo full logs to avoid exposing secrets)
              echo "Processing auto-fix request: $TITLE"
              
              # Build ISSUE_BODY for the auto-fixer script to consume
              ISSUE_BODY="## $TITLE"$'\n\n'"$DESCRIPTION"
              if [ -n "$ERROR_LOG" ]; then
                ISSUE_BODY+=$'\n\n'"### Error Log"$'\n'"$ERROR_LOG"
              fi
              if [ -n "$CONTEXT" ]; then
                ISSUE_BODY+=$'\n\n'"### Context"$'\n'"$CONTEXT"
              fi
              
              export ISSUE_BODY
              
              # Run auto-fixer in standard mode (it will read ISSUE_BODY from env)
              python scripts/auto_fixer_logic.py
            fi
          elif [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            echo "Running in standard mode (no pytest report)"
            python scripts/auto_fixer_logic.py
          else
            echo "Running in state machine mode with pytest report"
            python scripts/auto_fixer_logic.py --state report.json
          fi

      - name: Final Validation
        if: always()
        run: |
          echo "Estado Final: ${{ steps.healing_engine.outputs.final_state }}"
          # If the state is NEEDS_HUMAN or FAILED_LIMIT, the job should fail to notify the owner
          if [[ "${{ steps.healing_engine.outputs.final_state }}" == "NEEDS_HUMAN" ]] || [[ "${{ steps.healing_engine.outputs.final_state }}" == "FAILED_LIMIT" ]]; then
            echo "‚ö†Ô∏è Human intervention required"
            exit 1
          fi

      - name: Request Human Review
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.JARVIS_TOKEN_CI || github.token }}
          GH_TOKEN: ${{ secrets.JARVIS_TOKEN_CI || github.token }}
        run: |
          FINAL_STATE="${{ steps.healing_engine.outputs.final_state }}"
          ERROR_DETAILS="${{ steps.healing_engine.outputs.error_details }}"
          ATTEMPTED_FIXES="${{ steps.healing_engine.outputs.attempted_fixes }}"
          
          # Only request review if we actually have a failure state
          if [[ -z "$FINAL_STATE" ]] || [[ "$FINAL_STATE" == "SUCCESS" ]]; then
            echo "No human review needed - workflow succeeded or state not set"
            exit 0
          fi
          
          # Create detailed review request based on state
          if [[ "$FINAL_STATE" == "FAILED_LIMIT" ]]; then
            TITLE="üîß INTERVEN√á√ÉO HUMANA: Limite de Tentativas Atingido"
            STATUS="Limite de Tentativas Atingido"
            REASON="O sistema atingiu o limite m√°ximo de 3 tentativas de auto-reparo."
          elif [[ "$FINAL_STATE" == "NEEDS_HUMAN" ]]; then
            TITLE="üîç INTERVEN√á√ÉO HUMANA: Erro Requer An√°lise Manual"
            STATUS="Erro Requer An√°lise Manual"
            REASON="Erro de infraestrutura ou erro n√£o identificado detectado."
          else
            TITLE="üîç INTERVEN√á√ÉO HUMANA: Falha no Workflow"
            STATUS="Falha no Workflow"
            REASON="Falha inesperada no workflow de auto-reparo."
          fi
          
          # Build detailed review body
          REVIEW_BODY="## üö® INTERVEN√á√ÉO HUMANA NECESS√ÅRIA - $STATUS

          **Estado Final:** \`$FINAL_STATE\`
          **Motivo:** $REASON

          ### üìä Erro Identificado
          
          **Tipo de Erro:** Ver detalhes abaixo
          
          **Detalhes Completos:**
          \`\`\`
          ${ERROR_DETAILS:-"Nenhum detalhe de erro dispon√≠vel"}
          \`\`\`
          
          ### üß™ Testes Falhados
          
          Ver pytest report nos artefatos do workflow ou nos logs acima.
          
          ### üîß Corre√ß√µes Tentadas Automaticamente
          
          ${ATTEMPTED_FIXES:-"Nenhuma tentativa de corre√ß√£o foi registrada"}
          
          ### üí° Poss√≠vel Corre√ß√£o Sugerida
          
          Baseado nas tentativas autom√°ticas acima, considere:
          1. Revisar os logs de erro para identificar o padr√£o de falha
          2. Analisar as corre√ß√µes j√° tentadas para entender o que n√£o funcionou
          3. Aplicar corre√ß√£o manual no arquivo afetado
          4. Executar testes localmente antes de commit

          ### üìã An√°lise da Situa√ß√£o

          "
          
          if [[ "$FINAL_STATE" == "FAILED_LIMIT" ]]; then
            REVIEW_BODY+="#### Limite de Tentativas Atingido
          
          O sistema realizou 3 tentativas autom√°ticas de corre√ß√£o sem sucesso:
          
          1. **Primeira tentativa:** Corre√ß√£o m√≠nima aplicada, testes falharam
          2. **Segunda tentativa:** Corre√ß√£o alternativa aplicada, testes falharam  
          3. **Terceira tentativa:** √öltima tentativa de corre√ß√£o, testes falharam
          
          **Pr√≥ximos Passos:**
          - üîç Revise as tentativas de corre√ß√£o nos logs do workflow
          - üìù Analise o padr√£o de falhas entre as tentativas
          - ‚úèÔ∏è Aplique corre√ß√£o manual baseada nas tentativas autom√°ticas
          - üß™ Execute os testes localmente para validar
          "
          elif [[ "$FINAL_STATE" == "NEEDS_HUMAN" ]]; then
            REVIEW_BODY+="#### Interven√ß√£o Humana Necess√°ria
          
          O erro detectado requer an√°lise e corre√ß√£o manual:
          
          **Poss√≠veis Causas:**
          - üåê **Erro de Infraestrutura:** Timeout, ConnectionError, HTTP 429/500/503
          - ‚ùì **Erro Desconhecido:** Tipo de erro n√£o catalogado no sistema
          - üîí **Erro de Configura√ß√£o:** Vari√°veis de ambiente ou depend√™ncias
          
          **Pr√≥ximos Passos:**
          - üîç Verifique os logs completos do workflow
          - üåê Se for erro de infraestrutura, verifique conectividade e servi√ßos externos
          - üìö Se for erro desconhecido, analise o traceback completo
          - üîß Aplique corre√ß√£o manual ap√≥s identificar a causa raiz
          "
          fi
          
          REVIEW_BODY+="
          ### üìñ Logs e Recursos

          - **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - **Pytest Report:** Dispon√≠vel nos artefatos do workflow (se gerado)
          - **Estado da M√°quina:** \`$FINAL_STATE\`

          ### ‚úÖ Como Proceder

          1. **An√°lise:** Revise os logs do workflow e as informa√ß√µes acima
          2. **Diagn√≥stico:** Identifique a causa raiz do problema
          3. **Corre√ß√£o:** Aplique a corre√ß√£o necess√°ria manualmente
          4. **Valida√ß√£o:** Execute os testes para confirmar a corre√ß√£o
          5. **Documenta√ß√£o:** Atualize a issue com suas descobertas

          ---
          *Requisi√ß√£o de revis√£o criada automaticamente pelo Self-Healing State Machine*
          *Este n√£o √© um erro - √© uma solicita√ß√£o de revis√£o humana para casos complexos*"
          
          # Instead of creating a new issue, comment on the original issue
          # This avoids creating duplicate issues and keeps all context in one place
          ISSUE_NUMBER="${{ github.event_name == 'repository_dispatch' && env.DISPATCH_ISSUE_NUMBER || (github.event.issue.number || '') }}"
          
          if [[ -n "$ISSUE_NUMBER" ]]; then
            echo "Adding review request as comment to issue #$ISSUE_NUMBER"
            gh issue comment "$ISSUE_NUMBER" --body "$REVIEW_BODY"
          else
            echo "No issue number available, logging review request to workflow output"
            echo "$REVIEW_BODY"
          fi
