name: Jarvis Autonomous State Machine

# Self-Healing State Machine Implementation
# Follows the state machine logic for autonomous error fixing:
# - CHANGE_REQUESTED: Auto-fixable errors
# - NEEDS_HUMAN: Infrastructure/unidentified errors
# - SUCCESS: Fix applied successfully  
# - FAILED_LIMIT: Maximum attempts reached

on:
  pull_request:
  issues:
    types: [opened, edited]
  repository_dispatch:
    types: [jarvis_order, auto_fix]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  healing_engine:
    # Trigger on:
    # - Pull requests (for testing PRs)
    # - Issues with 'auto-code' or 'jarvis-auto-report' labels
    # - Repository dispatch events from Jarvis API ('jarvis_order' or 'auto_fix')
    if: |
      github.event_name == 'pull_request' ||
      contains(github.event.issue.labels.*.name, 'auto-code') ||
      contains(github.event.issue.labels.*.name, 'jarvis-auto-report') ||
      github.event_name == 'repository_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      final_state: ${{ steps.healing_engine.outputs.final_state }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          # Install test dependencies
          pip install pytest pytest-json-report pytest-cov
          # Install project dependencies if they exist
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt || echo "Some dependencies failed, continuing..."
          fi
          if [ -f "requirements/core.txt" ]; then
            pip install -r requirements/core.txt || echo "Some core dependencies failed, continuing..."
          fi
          if [ -f "requirements/dev.txt" ]; then
            pip install -r requirements/dev.txt || echo "Some dev dependencies failed, continuing..."
          fi

      - name: Handle Repository Dispatch (Jarvis API)
        id: handle_dispatch
        if: github.event_name == 'repository_dispatch'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Extract payload from repository_dispatch event
          INTENT="${{ github.event.client_payload.intent }}"
          INSTRUCTION="${{ github.event.client_payload.instruction }}"
          CONTEXT="${{ github.event.client_payload.context }}"
          TRIGGERED_BY="${{ github.event.client_payload.triggered_by }}"
          
          echo "Processing Jarvis API request:"
          echo "Intent: $INTENT"
          echo "Instruction: $INSTRUCTION"
          echo "Triggered by: $TRIGGERED_BY"
          
          # Build issue body from payload
          ISSUE_TITLE="ü§ñ Jarvis Request: $INTENT"
          ISSUE_BODY="## Solicita√ß√£o do Jarvis
          
          **Tipo:** $INTENT
          **Solicitado por:** $TRIGGERED_BY
          
          ### Instru√ß√£o
          $INSTRUCTION
          
          ### Contexto
          ${CONTEXT:-Nenhum contexto adicional fornecido}
          
          ---
          *Requisi√ß√£o criada automaticamente pela API do Jarvis*"
          
          # Create issue with auto-code label to trigger self-healing
          gh issue create \
            --title "$ISSUE_TITLE" \
            --body "$ISSUE_BODY" \
            --label "auto-code" \
            --label "jarvis-api" > issue_url.txt
          
          # Extract issue number from URL
          ISSUE_URL=$(cat issue_url.txt)
          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oP '/issues/\K\d+')
          
          echo "Created issue #$ISSUE_NUMBER"
          echo "DISPATCH_ISSUE_NUMBER=$ISSUE_NUMBER" >> $GITHUB_ENV
          echo "DISPATCH_ISSUE_BODY=$ISSUE_BODY" >> $GITHUB_ENV

      - name: Run Pytest (The Judge)
        id: tester
        if: github.event_name != 'repository_dispatch'
        run: |
          pytest --json-report --json-report-file=report.json || echo "TESTS_FAILED=true" >> $GITHUB_ENV
        continue-on-error: true

      - name: Self-Healing Logic
        id: healing_engine
        if: env.TESTS_FAILED == 'true' || github.event_name == 'repository_dispatch'
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_BODY: ${{ github.event_name == 'repository_dispatch' && env.DISPATCH_ISSUE_BODY || (github.event_name == 'issues' && github.event.issue.body || '') }}
          ISSUE_NUMBER: ${{ github.event_name == 'repository_dispatch' && env.DISPATCH_ISSUE_NUMBER || (github.event.issue.number || github.event.pull_request.number) }}
        run: |
          # Install GitHub CLI Copilot extension
          gh --version
          gh extension install github/gh-copilot || echo "Copilot extension already installed"
          
          # Configure Git
          git config --global user.name "Jarvis-Auto-Fixer"
          git config --global user.email "jarvis@bot.com"
          
          # Run auto-fixer (use standard mode for repository_dispatch, state machine mode for tests)
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            echo "Running in standard mode (no pytest report)"
            python scripts/auto_fixer_logic.py
          else
            echo "Running in state machine mode with pytest report"
            python scripts/auto_fixer_logic.py --state report.json
          fi

      - name: Final Validation
        if: always()
        run: |
          echo "Estado Final: ${{ steps.healing_engine.outputs.final_state }}"
          # If the state is NEEDS_HUMAN or FAILED_LIMIT, the job should fail to notify the owner
          if [[ "${{ steps.healing_engine.outputs.final_state }}" == "NEEDS_HUMAN" ]] || [[ "${{ steps.healing_engine.outputs.final_state }}" == "FAILED_LIMIT" ]]; then
            echo "‚ö†Ô∏è Human intervention required"
            exit 1
          fi

      - name: Request Human Review
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          FINAL_STATE="${{ steps.healing_engine.outputs.final_state }}"
          ERROR_DETAILS="${{ steps.healing_engine.outputs.error_details }}"
          ATTEMPTED_FIXES="${{ steps.healing_engine.outputs.attempted_fixes }}"
          
          # Only request review if we actually have a failure state
          if [[ -z "$FINAL_STATE" ]] || [[ "$FINAL_STATE" == "SUCCESS" ]]; then
            echo "No human review needed - workflow succeeded or state not set"
            exit 0
          fi
          
          # Create detailed review request based on state
          if [[ "$FINAL_STATE" == "FAILED_LIMIT" ]]; then
            TITLE="üîß Auto-Repair Needs Review: Maximum Attempts Reached"
            STATUS="‚ö†Ô∏è Revis√£o Necess√°ria"
            REASON="O sistema atingiu o limite m√°ximo de 3 tentativas de auto-reparo."
          elif [[ "$FINAL_STATE" == "NEEDS_HUMAN" ]]; then
            TITLE="üîç Auto-Repair Needs Review: Human Intervention Required"
            STATUS="‚ö†Ô∏è Revis√£o Necess√°ria"
            REASON="Erro de infraestrutura ou erro n√£o identificado detectado."
          else
            TITLE="üîç Auto-Repair Needs Review: Workflow Issue"
            STATUS="‚ö†Ô∏è Revis√£o Necess√°ria"
            REASON="Falha inesperada no workflow de auto-reparo."
          fi
          
          # Build detailed review body
          REVIEW_BODY="## $STATUS - Auto-Repair Review Request

          **Estado Final:** \`$FINAL_STATE\`
          **Motivo:** $REASON

          ### üìä Informa√ß√µes do Erro

          **Detalhes do Erro:**
          \`\`\`
          ${ERROR_DETAILS:-"Nenhum detalhe de erro dispon√≠vel"}
          \`\`\`

          ### üîß Tentativas de Corre√ß√£o

          ${ATTEMPTED_FIXES:-"Nenhuma tentativa de corre√ß√£o foi registrada"}

          ### üìã An√°lise da Situa√ß√£o

          "
          
          if [[ "$FINAL_STATE" == "FAILED_LIMIT" ]]; then
            REVIEW_BODY+="#### Limite de Tentativas Atingido
          
          O sistema realizou 3 tentativas autom√°ticas de corre√ß√£o sem sucesso:
          
          1. **Primeira tentativa:** Corre√ß√£o m√≠nima aplicada, testes falharam
          2. **Segunda tentativa:** Corre√ß√£o alternativa aplicada, testes falharam  
          3. **Terceira tentativa:** √öltima tentativa de corre√ß√£o, testes falharam
          
          **Pr√≥ximos Passos:**
          - üîç Revise as tentativas de corre√ß√£o nos logs do workflow
          - üìù Analise o padr√£o de falhas entre as tentativas
          - ‚úèÔ∏è Aplique corre√ß√£o manual baseada nas tentativas autom√°ticas
          - üß™ Execute os testes localmente para validar
          "
          elif [[ "$FINAL_STATE" == "NEEDS_HUMAN" ]]; then
            REVIEW_BODY+="#### Interven√ß√£o Humana Necess√°ria
          
          O erro detectado requer an√°lise e corre√ß√£o manual:
          
          **Poss√≠veis Causas:**
          - üåê **Erro de Infraestrutura:** Timeout, ConnectionError, HTTP 429/500/503
          - ‚ùì **Erro Desconhecido:** Tipo de erro n√£o catalogado no sistema
          - üîí **Erro de Configura√ß√£o:** Vari√°veis de ambiente ou depend√™ncias
          
          **Pr√≥ximos Passos:**
          - üîç Verifique os logs completos do workflow
          - üåê Se for erro de infraestrutura, verifique conectividade e servi√ßos externos
          - üìö Se for erro desconhecido, analise o traceback completo
          - üîß Aplique corre√ß√£o manual ap√≥s identificar a causa raiz
          "
          fi
          
          REVIEW_BODY+="
          ### üìñ Logs e Recursos

          - **Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          - **Pytest Report:** Dispon√≠vel nos artefatos do workflow (se gerado)
          - **Estado da M√°quina:** \`$FINAL_STATE\`

          ### ‚úÖ Como Proceder

          1. **An√°lise:** Revise os logs do workflow e as informa√ß√µes acima
          2. **Diagn√≥stico:** Identifique a causa raiz do problema
          3. **Corre√ß√£o:** Aplique a corre√ß√£o necess√°ria manualmente
          4. **Valida√ß√£o:** Execute os testes para confirmar a corre√ß√£o
          5. **Documenta√ß√£o:** Atualize a issue com suas descobertas

          ---
          *Requisi√ß√£o de revis√£o criada automaticamente pelo Self-Healing State Machine*
          *Este n√£o √© um erro - √© uma solicita√ß√£o de revis√£o humana para casos complexos*"
          
          # Instead of creating a new issue, comment on the original issue
          # This avoids creating duplicate issues and keeps all context in one place
          ISSUE_NUMBER="${{ github.event_name == 'repository_dispatch' && env.DISPATCH_ISSUE_NUMBER || (github.event.issue.number || '') }}"
          
          if [[ -n "$ISSUE_NUMBER" ]]; then
            echo "Adding review request as comment to issue #$ISSUE_NUMBER"
            gh issue comment "$ISSUE_NUMBER" --body "$REVIEW_BODY"
          else
            echo "No issue number available, logging review request to workflow output"
            echo "$REVIEW_BODY"
          fi
