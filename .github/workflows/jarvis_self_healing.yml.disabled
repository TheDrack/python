# ============================================================================
# WORKFLOW DESABILITADO - N√ÉO USAR
# ============================================================================
# 
# Este workflow foi desabilitado para evitar redund√¢ncias e loops de falhas.
# 
# MOTIVO: Substitu√≠do pelo Self-Healing State Machine (jarvis_code_fixer.yml)
# 
# O novo sistema usa uma m√°quina de estados determin√≠stica que:
# - Identifica tipos de erro automaticamente
# - Aplica at√© 3 tentativas de corre√ß√£o
# - Escala para revis√£o humana quando necess√°rio
# - Evita loops infinitos de falhas
# 
# Este arquivo foi mantido como .disabled para refer√™ncia hist√≥rica.
# Para usar o sistema de auto-corre√ß√£o, utilize o workflow:
# .github/workflows/jarvis_code_fixer.yml
# 
# Data de desabilita√ß√£o: 2026-02-09
# ============================================================================

name: Jarvis Self-Healing Auto-Code ü§ñ [DISABLED]

# Triggered by Jarvis API via repository_dispatch
# Receives intent (create/fix) and instruction from Jarvis
# Uses GitHub Copilot for native intelligence
# Tests changes and creates PR only if tests pass

on:
  repository_dispatch:
    types: [jarvis_order]

jobs:
  auto_code:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Validate Workflow Trigger
        id: validate
        run: |
          echo "========================================="
          echo "üîç Validating Workflow Trigger"
          echo "========================================="
          echo "Event name: ${{ github.event_name }}"
          echo "Event action: ${{ github.event.action }}"
          
          # Check if triggered correctly via repository_dispatch
          if [ "${{ github.event_name }}" != "repository_dispatch" ]; then
            echo "‚ùå ERROR: Workflow triggered incorrectly!"
            echo "Expected: repository_dispatch"
            echo "Got: ${{ github.event_name }}"
            echo ""
            echo "This workflow should ONLY be triggered via repository_dispatch with type 'jarvis_order'."
            echo "It appears to have been triggered by a ${{ github.event_name }} event."
            echo ""
            echo "WORKFLOW_VALID=false" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=Workflow triggered incorrectly. Expected repository_dispatch, got ${{ github.event_name }}" >> $GITHUB_ENV
            exit 1
          fi
          
          # Check if client_payload exists
          INTENT="${{ github.event.client_payload.intent }}"
          INSTRUCTION="${{ github.event.client_payload.instruction }}"
          
          if [ -z "$INTENT" ] || [ -z "$INSTRUCTION" ]; then
            echo "‚ùå ERROR: Missing required payload data!"
            echo "Intent: '$INTENT'"
            echo "Instruction: '$INSTRUCTION'"
            echo ""
            echo "The repository_dispatch event must include client_payload with:"
            echo "  - intent: 'create' or 'fix'"
            echo "  - instruction: description of what to do"
            echo "  - context: (optional) additional context"
            echo ""
            echo "WORKFLOW_VALID=false" >> $GITHUB_ENV
            echo "ERROR_MESSAGE=Missing required client_payload data (intent or instruction)" >> $GITHUB_ENV
            exit 1
          fi
          
          echo "‚úÖ Workflow trigger validation passed"
          echo "WORKFLOW_VALID=true" >> $GITHUB_ENV

      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git User
        run: |
          git config --global user.name "Jarvis-Auto-Code"
          git config --global user.email "jarvis-autocode[bot]@users.noreply.github.com"

      - name: Extract Jarvis Order
        id: order
        run: |
          echo "========================================="
          echo "üìã Extracting Jarvis Order"
          echo "========================================="
          echo "Intent: ${{ github.event.client_payload.intent }}"
          echo "Instruction: ${{ github.event.client_payload.instruction }}"
          echo "Context: ${{ github.event.client_payload.context }}"
          echo "Triggered by: ${{ github.event.client_payload.triggered_by }}"
          echo ""
          
          # Save to environment
          echo "JARVIS_INTENT=${{ github.event.client_payload.intent }}" >> $GITHUB_ENV
          echo "JARVIS_INSTRUCTION=${{ github.event.client_payload.instruction }}" >> $GITHUB_ENV
          echo "JARVIS_CONTEXT=${{ github.event.client_payload.context }}" >> $GITHUB_ENV
          
          echo "‚úÖ Order extracted successfully"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.cache/uv
            .venv
          key: ${{ runner.os }}-python-${{ hashFiles('requirements.txt', 'requirements/*.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-

      - name: Install GitHub Copilot CLI
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "========================================="
          echo "üì¶ Installing GitHub Copilot CLI"
          echo "========================================="
          gh --version
          
          # Install GitHub Copilot CLI extension
          echo "Installing GitHub Copilot CLI extension..."
          gh extension install github/gh-copilot || echo "‚ö†Ô∏è Copilot extension already installed"
          
          # Verify installation
          echo "Verifying installation..."
          if gh copilot --version; then
            echo "‚úÖ GitHub Copilot CLI installed successfully"
          else
            echo "‚ùå Failed to install GitHub Copilot CLI extension"
            echo "This may indicate:"
            echo "  - GitHub Copilot is not enabled for this account"
            echo "  - Network connectivity issues"
            echo "  - GitHub API rate limits"
            exit 1
          fi

      - name: Create Feature Branch
        run: |
          echo "========================================="
          echo "üåø Creating Feature Branch"
          echo "========================================="
          BRANCH_NAME="jarvis-auto-code-$(date +%s)"
          echo "Branch name: $BRANCH_NAME"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          
          if git checkout -b "$BRANCH_NAME"; then
            echo "‚úÖ Branch created successfully"
          else
            echo "‚ùå Failed to create branch"
            exit 1
          fi

      - name: Apply Code Changes with Copilot
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "========================================="
          echo "ü§ñ Applying Code Changes"
          echo "========================================="
          
          # Build the prompt for Copilot based on intent
          if [ "$JARVIS_INTENT" = "create" ]; then
            PROMPT="Create the following: $JARVIS_INSTRUCTION"
          else
            PROMPT="Fix the following: $JARVIS_INSTRUCTION"
          fi
          
          if [ ! -z "$JARVIS_CONTEXT" ]; then
            PROMPT="$PROMPT. Context: $JARVIS_CONTEXT"
          fi
          
          echo "Intent: $JARVIS_INTENT"
          echo "Prompt: $PROMPT"
          echo ""
          
          # NOTE: This is a placeholder implementation for the workflow structure.
          # In production, this should integrate with:
          # 1. GitHub Copilot API (when available for Actions) - Use official API to generate code
          # 2. Alternative LLM (e.g., GPT-4, Claude) - For more complex code generation tasks
          # 3. Custom code generation logic - Based on instruction parsing and templates
          #
          # The current implementation creates a marker file to demonstrate the workflow.
          # Future enhancement: Replace with actual code generation using gh copilot or LLM API
          python3 << 'PYTHON_SCRIPT'
import os
import subprocess
import sys

intent = os.getenv('JARVIS_INTENT')
instruction = os.getenv('JARVIS_INSTRUCTION')
context = os.getenv('JARVIS_CONTEXT', '')

# For now, we'll create a placeholder to show the workflow ran
# TODO: Integrate with GitHub Copilot API or LLM for actual code generation
print(f"üìù Processing {intent} request: {instruction}")

# This is a placeholder - in real implementation:
# 1. Use gh copilot or GitHub API to get code suggestions
# 2. Apply changes to files based on instruction
# 3. For now, we'll create a marker file to show the workflow ran

marker_file = f".jarvis_order_{intent}_{os.getenv('GITHUB_RUN_ID')}.txt"
with open(marker_file, 'w') as f:
    f.write(f"Intent: {intent}\n")
    f.write(f"Instruction: {instruction}\n")
    f.write(f"Context: {context}\n")
    f.write(f"Status: Placeholder - Changes would be applied here using GitHub Copilot or LLM\n")

print(f"‚úÖ Created marker file: {marker_file}")
print("‚ö†Ô∏è NOTE: This is a placeholder implementation. Actual code changes require integration with GitHub Copilot API or LLM.")
PYTHON_SCRIPT

      - name: Detect Test Command
        id: test_cmd
        run: |
          echo "========================================="
          echo "üîç Detecting Test Framework"
          echo "========================================="
          # Auto-detect test command based on repository structure
          if [ -f "pytest.ini" ] || [ -f "setup.cfg" ]; then
            echo "TEST_CMD=pytest tests/ -v" >> $GITHUB_ENV
            echo "‚úÖ Test framework: pytest (found pytest.ini or setup.cfg)"
          elif find requirements -name "*.txt" -exec grep -q pytest {} \; 2>/dev/null; then
            echo "TEST_CMD=pytest tests/ -v" >> $GITHUB_ENV
            echo "‚úÖ Test framework: pytest (found in requirements/)"
          elif grep -q pytest requirements.txt 2>/dev/null; then
            echo "TEST_CMD=pytest tests/ -v" >> $GITHUB_ENV
            echo "‚úÖ Test framework: pytest (found in requirements.txt)"
          elif [ -f "package.json" ] && grep -q "\"test\":" package.json; then
            echo "TEST_CMD=npm test" >> $GITHUB_ENV
            echo "‚úÖ Test framework: npm"
          elif [ -f "Makefile" ] && grep -q "^test:" Makefile; then
            echo "TEST_CMD=make test" >> $GITHUB_ENV
            echo "‚úÖ Test framework: make"
          else
            echo "TEST_CMD=echo 'No tests found, skipping'" >> $GITHUB_ENV
            echo "‚ö†Ô∏è No test framework detected - tests will be skipped"
          fi

      - name: Install Test Dependencies
        if: contains(env.TEST_CMD, 'pytest')
        run: |
          echo "========================================="
          echo "üì¶ Installing Test Dependencies"
          echo "========================================="
          # Install dependencies for Python projects
          if [ -f "requirements.txt" ]; then
            echo "Installing requirements.txt..."
            pip install -r requirements.txt
          fi
          
          # Install test dependencies
          if [ -f "requirements/dev.txt" ]; then
            echo "Installing requirements/dev.txt..."
            pip install -r requirements/dev.txt
          fi
          
          # Ensure pytest is installed
          echo "Installing pytest and pytest-cov..."
          pip install pytest pytest-cov
          
          echo "‚úÖ Test dependencies installed successfully"

      - name: Run Tests with Auto-Fix Retry Logic
        id: tests_with_retry
        continue-on-error: true
        run: |
          echo "========================================="
          echo "üß™ Running Tests with Auto-Fix Retry Logic"
          echo "========================================="
          MAX_RETRIES=3
          RETRY_COUNT=0
          TEST_PASSED=false
          
          echo "Starting tests with auto-fix retry logic (max $MAX_RETRIES attempts)"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "========================================="
            echo "Test Attempt $(($RETRY_COUNT + 1)) of $MAX_RETRIES"
            echo "========================================="
            
            # Run tests
            if $TEST_CMD; then
              echo "‚úÖ Tests passed on attempt $(($RETRY_COUNT + 1))"
              TEST_PASSED=true
              break
            else
              echo "‚ùå Tests failed on attempt $(($RETRY_COUNT + 1))"
              RETRY_COUNT=$(($RETRY_COUNT + 1))
              
              # If not the last attempt, try to auto-fix
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Attempting to analyze and fix test failures..."
                
                # Capture test output for analysis
                $TEST_CMD 2>&1 | tee test_output_attempt_${RETRY_COUNT}.log || true
                
                # TODO: Integrate with LLM or GitHub Copilot to analyze test failures
                # and suggest fixes. For now, we log the failure for manual review.
                echo "Test failure logged to test_output_attempt_${RETRY_COUNT}.log"
                
                # Placeholder for auto-fix logic
                # In production, this would:
                # 1. Analyze test output
                # 2. Use LLM/Copilot to generate fixes
                # 3. Apply fixes to code
                # 4. Retry tests
                
                echo "Auto-fix attempt $(($RETRY_COUNT)) - Currently placeholder implementation"
                echo "Waiting 2 seconds before retry..."
                sleep 2
              fi
            fi
          done
          
          # Set environment variables for subsequent steps
          echo "TEST_PASSED=$TEST_PASSED" >> $GITHUB_ENV
          echo "RETRY_COUNT=$RETRY_COUNT" >> $GITHUB_ENV
          
          if [ "$TEST_PASSED" = "true" ]; then
            echo "Final result: Tests passed after $RETRY_COUNT attempt(s)"
            exit 0
          else
            echo "Final result: Tests failed after $MAX_RETRIES attempts"
            exit 1
          fi

      - name: Commit Changes
        if: always()
        run: |
          echo "========================================="
          echo "üíæ Committing Changes"
          echo "========================================="
          
          # Check for changes
          if git diff --quiet && git diff --cached --quiet; then
            echo "‚ÑπÔ∏è No changes to commit"
            echo "HAS_CHANGES=false" >> $GITHUB_ENV
            exit 0
          fi
          
          git add .
          
          # Create appropriate commit message based on test results
          if [ "$TEST_PASSED" = "true" ]; then
            COMMIT_MSG="ü§ñ Jarvis Auto-Code: $JARVIS_INTENT - $JARVIS_INSTRUCTION"
            if [ "${RETRY_COUNT:-0}" -gt 0 ]; then
              COMMIT_MSG="$COMMIT_MSG (fixed after $RETRY_COUNT attempt(s))"
            fi
          else
            COMMIT_MSG="ü§ñ Jarvis Auto-Code: $JARVIS_INTENT - $JARVIS_INSTRUCTION (needs review - tests failed after ${RETRY_COUNT:-0} attempts)"
          fi
          
          echo "Commit message: $COMMIT_MSG"
          
          if git commit -m "$COMMIT_MSG"; then
            echo "‚úÖ Changes committed successfully"
            echo "HAS_CHANGES=true" >> $GITHUB_ENV
          else
            echo "‚ùå Failed to commit changes"
            echo "HAS_CHANGES=false" >> $GITHUB_ENV
            exit 0
          fi

      - name: Push Branch
        if: env.HAS_CHANGES == 'true'
        run: |
          echo "========================================="
          echo "‚¨ÜÔ∏è Pushing Branch"
          echo "========================================="
          echo "Branch: $BRANCH_NAME"
          
          if git push origin "$BRANCH_NAME"; then
            echo "‚úÖ Branch pushed successfully"
          else
            echo "‚ùå Failed to push branch"
            exit 1
          fi

      - name: Create Pull Request
        if: env.HAS_CHANGES == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "========================================="
          echo "üìù Creating Pull Request"
          echo "========================================="
          # Determine PR title and body based on test results
          if [ "$TEST_PASSED" = "true" ]; then
            PR_TITLE="ü§ñ Jarvis: $JARVIS_INTENT - $JARVIS_INSTRUCTION"
            
            if [ "$RETRY_COUNT" -eq 0 ]; then
              STATUS_MSG="‚úÖ All tests passed on first attempt"
            else
              STATUS_MSG="‚úÖ All tests passed after $RETRY_COUNT auto-fix attempt(s)"
            fi
            
            PR_BODY="## ü§ñ Jarvis Self-Healing Auto-Code

**Intent:** $JARVIS_INTENT
**Instruction:** $JARVIS_INSTRUCTION
**Context:** $JARVIS_CONTEXT

### ‚úÖ Quality Check
- Tests executed: $TEST_CMD
- Result: $STATUS_MSG

### üìä Workflow Details
- Triggered by: ${{ github.event.client_payload.triggered_by }}
- Workflow run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

---
*Generated automatically by Jarvis Self-Healing System*"
          else
            PR_TITLE="üîß Jarvis: $JARVIS_INTENT - $JARVIS_INSTRUCTION (Needs Review)"
            
            PR_BODY="## ü§ñ Jarvis Self-Healing Auto-Code - Needs Manual Review

**Intent:** $JARVIS_INTENT
**Instruction:** $JARVIS_INSTRUCTION
**Context:** $JARVIS_CONTEXT

### ‚ö†Ô∏è Quality Check - Needs Attention
- Tests executed: $TEST_CMD
- Result: ‚ùå Tests failed after $RETRY_COUNT auto-fix attempts
- Status: **Requires manual review and intervention**

### üìã Test Failure Report
The automated fix attempts were unsuccessful. Please review the workflow logs and test output files for detailed information:

- Workflow run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
- Test attempt logs: \`test_output_attempt_*.log\`

### üîç Next Steps
1. Review the test failure logs in the workflow run
2. Analyze the root cause of the failures
3. Apply manual fixes or provide additional context to Jarvis
4. Re-run tests or trigger a new fix attempt

### üìä Workflow Details
- Triggered by: ${{ github.event.client_payload.triggered_by }}
- Auto-fix attempts: $RETRY_COUNT
- Workflow run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}

---
*Generated automatically by Jarvis Self-Healing System*"
          fi
          
          echo "Creating PR with title: $PR_TITLE"
          
          if gh pr create \
            --title "$PR_TITLE" \
            --body "$PR_BODY" \
            --base "${{ github.event.repository.default_branch }}" \
            --head "$BRANCH_NAME"; then
            echo "‚úÖ Pull request created successfully"
          else
            echo "‚ö†Ô∏è Failed to create PR - it might already exist"
            echo "Attempting to list existing PRs for this branch..."
            gh pr list --head "$BRANCH_NAME" || true
          fi

      - name: Workflow Summary
        if: always()
        run: |
          echo "=========================================" >> $GITHUB_STEP_SUMMARY
          echo "## ü§ñ Jarvis Self-Healing Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "=========================================" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Check if workflow validation failed
          if [ "${WORKFLOW_VALID:-true}" != "true" ]; then
            echo "### ‚ùå Workflow Validation Failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Error:** ${ERROR_MESSAGE:-Unknown validation error}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "#### üìã Trigger Information" >> $GITHUB_STEP_SUMMARY
            echo "- **Event:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Ref:** ${{ github.ref }}" >> $GITHUB_STEP_SUMMARY
            echo "- **SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "#### ‚úÖ Expected Trigger" >> $GITHUB_STEP_SUMMARY
            echo "This workflow should be triggered via \`repository_dispatch\` event with:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
            echo "{" >> $GITHUB_STEP_SUMMARY
            echo "  \"event_type\": \"jarvis_order\"," >> $GITHUB_STEP_SUMMARY
            echo "  \"client_payload\": {" >> $GITHUB_STEP_SUMMARY
            echo "    \"intent\": \"create\" or \"fix\"," >> $GITHUB_STEP_SUMMARY
            echo "    \"instruction\": \"description of what to do\"," >> $GITHUB_STEP_SUMMARY
            echo "    \"context\": \"optional additional context\"," >> $GITHUB_STEP_SUMMARY
            echo "    \"triggered_by\": \"optional trigger source\"" >> $GITHUB_STEP_SUMMARY
            echo "  }" >> $GITHUB_STEP_SUMMARY
            echo "}" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "#### üìñ How to Trigger" >> $GITHUB_STEP_SUMMARY
            echo "Use the GitHub API to send a repository_dispatch event:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
            echo "curl -X POST \\" >> $GITHUB_STEP_SUMMARY
            echo "  -H \"Accept: application/vnd.github+json\" \\" >> $GITHUB_STEP_SUMMARY
            echo "  -H \"Authorization: Bearer YOUR_TOKEN\" \\" >> $GITHUB_STEP_SUMMARY
            echo "  https://api.github.com/repos/${{ github.repository }}/dispatches \\" >> $GITHUB_STEP_SUMMARY
            echo "  -d '{\"event_type\":\"jarvis_order\",\"client_payload\":{\"intent\":\"fix\",\"instruction\":\"Your instruction here\"}}'" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Workflow run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi
          
          echo "### üìã Request Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Intent:** ${JARVIS_INTENT:-N/A}" >> $GITHUB_STEP_SUMMARY
          echo "- **Instruction:** ${JARVIS_INSTRUCTION:-N/A}" >> $GITHUB_STEP_SUMMARY
          if [ -n "$JARVIS_CONTEXT" ]; then
            echo "- **Context:** $JARVIS_CONTEXT" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Status based on execution
          if [ "$TEST_PASSED" = "true" ] && [ "${HAS_CHANGES:-false}" = "true" ]; then
            echo "### ‚úÖ Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
            if [ "${RETRY_COUNT:-0}" -eq 0 ]; then
              echo "Tests passed on first attempt, PR created successfully" >> $GITHUB_STEP_SUMMARY
            else
              echo "Tests passed after $RETRY_COUNT auto-fix attempt(s), PR created successfully" >> $GITHUB_STEP_SUMMARY
            fi
          elif [ "${HAS_CHANGES:-false}" = "true" ]; then
            echo "### ‚ö†Ô∏è Status: NEEDS REVIEW" >> $GITHUB_STEP_SUMMARY
            echo "Tests failed after ${RETRY_COUNT:-0} attempts, PR created for manual review" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Action Required:** Please review the PR and test failure logs" >> $GITHUB_STEP_SUMMARY
          elif [ "${HAS_CHANGES:-false}" = "false" ]; then
            echo "### ‚ÑπÔ∏è Status: NO CHANGES" >> $GITHUB_STEP_SUMMARY
            echo "No changes were needed or generated" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Status: FAILED" >> $GITHUB_STEP_SUMMARY
            echo "Unable to process request - check workflow logs for details" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
