#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Fire Test Script - Validate Jarvis Auto-Repair System

This is a STANDALONE SCRIPT (not a pytest test file) that tests the auto-repair
functionality by:
1. Intentionally creating an error (import or syntax error)
2. Capturing the error with traceback
3. Sending the error to GitHub Actions via GitHubAdapter.dispatch_auto_fix()
4. Validating that the workflow is triggered

Note: This script uses asyncio and should be run directly, not via pytest.

Usage:
    python tests/test_auto_repair.py --error-type [import|syntax|missing-comma]
"""

import argparse
import asyncio
import logging
import os
import sys
import traceback
from pathlib import Path

# Add project root to path (repository root, not tests directory)
sys.path.insert(0, str(Path(__file__).parent.parent))

from app.adapters.infrastructure.github_adapter import GitHubAdapter

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


async def simulate_import_error():
    """Simulate auto-repair with an import error"""
    logger.info("ðŸ”¥ Simulating auto-repair with import error...")
    
    try:
        # This will intentionally fail
        import nonexistent_module_for_testing  # noqa: F401
    except ImportError as e:
        error_traceback = traceback.format_exc()
        logger.info(f"âœ… Successfully captured import error:\n{error_traceback}")
        return {
            "error": e,
            "traceback": error_traceback,
            "error_type": "ImportError"
        }


async def simulate_syntax_error():
    """Simulate auto-repair with a syntax error"""
    logger.info("ðŸ”¥ Simulating auto-repair with syntax error...")
    
    # Create a temporary file with syntax error
    temp_file = Path("/tmp/test_syntax_error.py")
    temp_file.write_text("def broken_function(\n    print('missing closing paren')\n")
    
    try:
        # Try to compile the file
        with open(temp_file, 'r') as f:
            compile(f.read(), str(temp_file), 'exec')
    except SyntaxError as e:
        error_traceback = traceback.format_exc()
        logger.info(f"âœ… Successfully captured syntax error:\n{error_traceback}")
        temp_file.unlink()  # Clean up
        return {
            "error": e,
            "traceback": error_traceback,
            "error_type": "SyntaxError"
        }
    finally:
        if temp_file.exists():
            temp_file.unlink()


async def simulate_missing_comma():
    """Simulate auto-repair with a missing comma"""
    logger.info("ðŸ”¥ Simulating auto-repair with missing comma...")
    
    # Create a temporary file with missing comma
    temp_file = Path("/tmp/test_missing_comma.py")
    temp_file.write_text("""
data = {
    'name': 'test'
    'value': 123  # Missing comma on previous line
}
""")
    
    try:
        # Try to compile the file
        with open(temp_file, 'r') as f:
            compile(f.read(), str(temp_file), 'exec')
    except SyntaxError as e:
        error_traceback = traceback.format_exc()
        logger.info(f"âœ… Successfully captured syntax error (missing comma):\n{error_traceback}")
        temp_file.unlink()  # Clean up
        return {
            "error": e,
            "traceback": error_traceback,
            "error_type": "SyntaxError (missing comma)"
        }
    finally:
        if temp_file.exists():
            temp_file.unlink()


async def dispatch_auto_fix(error_data: dict) -> None:
    """Dispatch auto-fix to GitHub Actions"""
    logger.info("ðŸ“¤ Dispatching auto-fix to GitHub Actions...")
    
    # Check if GitHub token is configured
    github_token = os.getenv("GITHUB_TOKEN")
    if not github_token:
        logger.warning(
            "âš ï¸ GITHUB_TOKEN not configured. Skipping actual dispatch.\n"
            "To test the full flow, set GITHUB_TOKEN environment variable."
        )
        logger.info("ðŸ“‹ Would have dispatched the following payload:")
        logger.info(f"  Issue: {error_data['error_type']}")
        logger.info(f"  Error: {error_data['error']}")
        logger.info(f"  Traceback preview: {error_data['traceback'][:200]}...")
        return
    
    # Create GitHub adapter
    adapter = GitHubAdapter()
    
    # For this test, we'll create a simple fix
    # In a real scenario, an AI would analyze the error and formulate the fix
    fix_code = f"""# Auto-generated fix for {error_data['error_type']}
# This is a placeholder fix for testing purposes
# In production, an AI would analyze the error and generate the actual fix

# Error: {error_data['error']}
# This file was auto-generated by Jarvis Auto-Repair System
"""
    
    # Prepare the issue data
    issue_data = {
        "issue_title": f"Auto-fix: {error_data['error_type']} detected in test",
        "file_path": "test_auto_repair_output.txt",
        "fix_code": fix_code,
        "test_command": "echo 'Test completed successfully'"
    }
    
    # Dispatch the auto-fix
    result = await adapter.dispatch_auto_fix(issue_data)
    
    if result.get("success"):
        logger.info("âœ… Auto-fix dispatched successfully!")
        logger.info(f"   Workflow URL: {result.get('workflow_url')}")
        logger.info(f"   Message: {result.get('message')}")
    else:
        logger.error(f"âŒ Failed to dispatch auto-fix: {result.get('error')}")


async def main():
    """Main test runner"""
    parser = argparse.ArgumentParser(description="Test Jarvis Auto-Repair System")
    parser.add_argument(
        "--error-type",
        choices=["import", "syntax", "missing-comma", "all"],
        default="import",
        help="Type of error to test (default: import)"
    )
    args = parser.parse_args()
    
    logger.info("ðŸš€ Starting Jarvis Auto-Repair Fire Test")
    logger.info(f"   Error type: {args.error_type}")
    logger.info("=" * 60)
    
    error_tests = []
    
    if args.error_type == "all":
        error_tests = [
            ("import", simulate_import_error),
            ("syntax", simulate_syntax_error),
            ("missing-comma", simulate_missing_comma),
        ]
    elif args.error_type == "import":
        error_tests = [("import", simulate_import_error)]
    elif args.error_type == "syntax":
        error_tests = [("syntax", simulate_syntax_error)]
    elif args.error_type == "missing-comma":
        error_tests = [("missing-comma", simulate_missing_comma)]
    
    for test_name, test_func in error_tests:
        logger.info(f"\n{'=' * 60}")
        logger.info(f"Running test: {test_name}")
        logger.info(f"{'=' * 60}\n")
        
        error_data = await test_func()
        
        if error_data:
            await dispatch_auto_fix(error_data)
        else:
            logger.error(f"âŒ Test {test_name} failed to generate error data")
        
        # Wait a bit between tests
        if len(error_tests) > 1:
            logger.info("\nWaiting 2 seconds before next test...")
            await asyncio.sleep(2)
    
    logger.info(f"\n{'=' * 60}")
    logger.info("âœ… Fire test completed!")
    logger.info("=" * 60)
    logger.info("\nNext steps:")
    logger.info("1. Check GitHub Actions workflows at:")
    logger.info("   https://github.com/TheDrack/python/actions/workflows/jarvis_code_fixer.yml")
    logger.info("2. Verify that the auto-fix workflow was triggered")
    logger.info("3. Review the auto-generated PR (if workflow succeeded)")


if __name__ == "__main__":
    asyncio.run(main())
